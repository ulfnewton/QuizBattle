# **Uppgift: Refaktorera QuizBattle med OOP-principer**

**Datum:** Vecka 2, Dag 2  
**Syfte:** Fördjupa förståelsen för arv, komposition, gränssnitt och polymorfism genom att refaktorera din befintliga QuizBattle-kod.

***

## **Lärandemål**

Efter uppgiften ska du kunna:

*   Förklara skillnaden mellan arv och komposition.
*   Implementera ett gränssnitt och använda det för att skapa utbytbara komponenter.
*   Tillämpa polymorfism i praktiken.
*   Använda Git för versionshantering (branch, commit, PR).

***

## **Förutsättningar**

*   Du har en fungerande QuizBattle från dag 1 (med implementerade metoder).
*   Du arbetar i Visual Studio eller VS Code.
*   Du har ett GitHub-repo för kursen.

***

## **Instruktioner – Steg för steg**

### **Steg 1: Skapa en ny branch**

```bash
git checkout -b feature/w2-oop-refactor
```

***

### **Steg 2: Skapa en serviceklass (komposition)**

1.  Skapa en ny klass `QuestionService`:

```csharp
public class QuestionService
{
    private readonly List<Question> _questions;

    public QuestionService(List<Question> questions)
    {
        _questions = questions;
    }

    public Question GetRandomQuestion()
        => _questions[new Random().Next(_questions.Count)];
}
```

**Diskussion:** Varför är komposition bättre än arv här?

***

### **Steg 3: Introducera ett gränssnitt**

1.  Skapa `IQuestionRepository`:

```csharp
public interface IQuestionRepository
{
    List<Question> GetAll();
}
```

2.  Implementera `InMemoryQuestionRepository`:

```csharp
public class InMemoryQuestionRepository : IQuestionRepository
{
    public List<Question> GetAll() => QuestionUtils.Seed();
}
```

3.  Ändra `QuestionService`:

```csharp
public class QuestionService
{
    private readonly IQuestionRepository _repo;

    public QuestionService(IQuestionRepository repo)
    {
        _repo = repo;
    }

    public Question GetRandomQuestion()
        => _repo.GetAll()[new Random().Next(_repo.GetAll().Count)];
}
```

***

### **Steg 4: Demonstrera polymorfism**

*   Skapa en alternativ implementation, t.ex. `FileQuestionRepository` (mocka med hårdkodad lista).
*   Visa hur du kan byta implementation i `Program.cs`:

```csharp
var repo = new InMemoryQuestionRepository();
var service = new QuestionService(repo);
var question = service.GetRandomQuestion();
```

***

### **Steg 5: Git – Commit & Pull Request**

```bash
git add .
git commit -m "Refactor: Introduce QuestionService and IQuestionRepository"
git push origin feature/w2-oop-refactor
```

Skapa en PR och be en klasskamrat att göra en review.

***

## **Reflektionsfrågor**

*   När är komposition att föredra framför arv?
*   Hur gör interface koden mer flexibel och testbar?
*   Ge ett exempel på polymorfism från din kod.
*   Vad är fördelen med att använda PR för kodgranskning?

***

## **Definition of Done**

*   `QuestionService` implementerad med komposition.
*   `IQuestionRepository` och minst en implementation (`InMemoryQuestionRepository`).
*   Programmet kompilerar och kör med den nya strukturen.
*   Branch skapad, commit gjord, PR skapad.
*   Reflektionsfrågor besvarade.
