# Code-along: Från Console-app till Application- och API-lager

## Kontext och mål
Vi **har redan en fungerande konsolapplikation**.  
Den gör sitt jobb och innehåller både flöde, logik och domänanvändning.

I den här code-alongen fokuserar vi **inte** på konsolen längre.

👉 Vårt mål är att:
- Extrahera applikationslogik till ett **Application-lager**
- Exponera funktionaliteten via ett **API-lager**
- Återanvända befintlig domänmodell
- Förbereda lösningen för fler klienter (web, mobil, etc.)

Konsolappen blir därmed *en klient bland flera*.

---

## Översikt: Nya arkitekturen

### 1. Domain (oförändrat)
**Ansvar**
- Affärsregler
- Konsistens
- Beteende

**Exempel**
- `Question`
- `Choice`
- `QuizSession`
- Domänvalidering

👉 Domain känner **inget** till:
- Console
- API
- Repositories
- HTTP
- Tidskällor

---

### 2. Application (nytt fokus)
**Ansvar**
- Use cases / scenarier
- Applikationsflöde
- Orkestrering av domänobjekt

**Application innehåller**
- Commands och Results
- HandleAsync(s (Start session, Answer question, Finish session)
- Interfaces (ports):
  - `IQuestionRepository`
  - `ISessionRepository`

👉 Application:
- Känner till **Domain**
- Känner till **abstraktioner**
- Känner inte till **implementationsdetaljer**

---

### 3. API (nytt lager)
**Ansvar**
- HTTP
- Routing
- DTO:er
- Statuskoder
- Dependency Injection
- In-memory implementationer (temporärt)

API är en **adapter** mot Application.

👉 API:
- Översätter HTTP → Application
- Översätter Application → HTTP
- Innehåller inga affärsregler

---

### 4. Console (sekundär klient)
Konsolappen:
- Kan leva kvar
- Ska i framtiden kunna anropa Application på samma sätt som API:t
- Är inte längre centrum i arkitekturen

---

## Flöde genom lagren (mentalt schema)

```

HTTP Request
↓
API (DTO + routing)
↓
Application (HandleAsync( + use case)
↓
Domain (beteende och regler)
↓
Application (Result)
↓
API (HTTP response)

```

---

## Vad vi ska göra i **Application-lagret**

### 1. Identifiera use cases
Vi formaliserar det som redan finns i konsolen:

- Starta en quiz-session
- Svara på en fråga
- Avsluta en session

Varje use case blir:
- Ett **Command**
- Ett **Result**
- En **HandleAsync(**

---

### 2. Flytta orkestrering från klienten
Logik som:
- Välja frågor
- Skapa session
- Räkna poäng
- Registrera svar

…ska **inte** ligga i API eller Console.

👉 Den ska ligga i Application.

---

### 3. Introducera portar (interfaces)
För allt som Application inte äger:

- Frågedata → `IQuestionRepository`
- Sessionslagring → `ISessionRepository`

Application kodas **som om dessa redan fanns**.

---

### 4. Säkerställ att Application är UI-agnostiskt
I Application får det **inte** finnas:
- `Console`
- `HttpContext`
- `Controller`
- `Results`
- Statuskoder

Om något sådant behövs → det hör hemma i API.

---

## Vad vi ska göra i **API-lagret**

### 1. Skapa API-endpoints som adapters
För varje use case i Application:

- En HTTP-endpoint
- Ett DTO-objekt (request)
- Mappning till Command
- Anrop av HandleAsync(
- Mappning till HTTP-response

---

### 2. Implementera infrastructure lokalt
Temporärt, i API:

- In-memory repositories
- Systemklocka
- Enkel DI-registrering

👉 Detta är **utbytbart** och ska inte läcka in i Application.

---

### 3. Hantera tekniska beslut
API ansvarar för:
- Statuskoder (`200`, `400`, `404`)
- `ProblemDetails`
- Routing
- Swagger

Application returnerar **resultat**, inte HTTP-begrepp.

---

## Viktiga designregler under code-alongen

- Application får **aldrig** referera API
- Domain får **aldrig** referera Application
- API får referera både Application och Domain
- All affärslogik ska kunna testas utan HTTP

---

## Efter code-alongen ska ni kunna
- Förklara varför Console inte längre är centrum
- Peka ut var ett nytt use case ska implementeras
- Bygga en ny klient utan att röra Application
- Se hur detta naturligt kan skalas med databas, auth och tester

Detta är övergången från *”övningsapp”* till *riktig backend-arkitektur*.

Code-along: Från Console-app till Application- och API-lager
Kontext och mål
Vi har redan en fungerande konsolapplikation.
Den gör sitt jobb och innehåller både flöde, logik och domänanvändning.
I den här code-alongen fokuserar vi inte på konsolen längre.
👉 Vårt mål är att:
-	Extrahera applikationslogik till ett Application-lager
-	Exponera funktionaliteten via ett API-lager
-	Återanvända befintlig domänmodell
-	Förbereda lösningen för fler klienter (web, mobil, etc.)
Konsolappen blir därmed en klient bland flera.
________________________________________
Översikt: Nya arkitekturen
1. Domain (oförändrat)
Ansvar
-	Affärsregler
-	Konsistens
-	Beteende
Exempel
-	Question
-	Choice
-	QuizSession
-	Domänvalidering
👉 Domain känner inget till:
-	Console
-	API
-	Repositories
-	HTTP
-	Tidskällor
________________________________________
2. Application (nytt fokus)
Ansvar
-	Use cases / scenarier
-	Applikationsflöde
-	Orkestrering av domänobjekt
Application innehåller
-	Commands och Results
-	HandleAsync(s (Start session, Answer question, Finish session)
-	Interfaces (ports):
-	IQuestionRepository
-	ISessionRepository
👉 Application:
-	Känner till Domain
-	Känner till abstraktioner
-	Känner inte till implementationsdetaljer
________________________________________
3. API (nytt lager)
Ansvar
-	HTTP
-	Routing
-	DTO:er
-	Statuskoder
-	Dependency Injection
-	In-memory implementationer (temporärt)
API är en adapter mot Application.
👉 API:
-	Översätter HTTP → Application
-	Översätter Application → HTTP
-	Innehåller inga affärsregler
________________________________________
4. Console (sekundär klient)
Konsolappen:
-	Kan leva kvar
-	Ska i framtiden kunna anropa Application på samma sätt som API:t
-	Är inte längre centrum i arkitekturen
________________________________________
Flöde genom lagren (mentalt schema)

HTTP Request
↓
API (DTO + routing)
↓
Application (HandleAsync( + use case)
↓
Domain (beteende och regler)
↓
Application (Result)
↓
API (HTTP response)

________________________________________
Vad vi ska göra i Application-lagret
1. Identifiera use cases
Vi formaliserar det som redan finns i konsolen:
-	Starta en quiz-session
-	Svara på en fråga
-	Avsluta en session
Varje use case blir:
-	Ett Command
-	Ett Result
-	En HandleAsync(
________________________________________
2. Flytta orkestrering från klienten
Logik som:
-	Välja frågor
-	Skapa session
-	Räkna poäng
-	Registrera svar
…ska inte ligga i API eller Console.
👉 Den ska ligga i Application.
________________________________________
3. Introducera portar (interfaces)
För allt som Application inte äger:
-	Frågedata → IQuestionRepository
-	Sessionslagring → ISessionRepository
Application kodas som om dessa redan fanns.
________________________________________
4. Säkerställ att Application är omedveten om andra lager
I Application får det inte finnas:
-	Console
-	HttpContext
-	Controller
-	Results
-	Statuskoder
Om något sådant behövs → det hör hemma i API.
________________________________________
Vad vi ska göra i API-lagret
1. Skapa API-endpoints som adapters
För varje use case i Application:
-	En HTTP-endpoint
-	Ett DTO-objekt (request)
-	Mappning till Command
-	Anrop av HandleAsync(
-	Mappning till HTTP-response
________________________________________
2. Implementera infrastructure lokalt
Temporärt, i API:
-	In-memory repositories
-	Systemklocka
-	Enkel DI-registrering
👉 Detta är utbytbart och ska inte läcka in i Application.
________________________________________
3. Hantera tekniska beslut
API ansvarar för:
-	Statuskoder (200, 400, 404)
-	ProblemDetails
-	Routing
-	Swagger
Application returnerar resultat, inte HTTP-begrepp.
________________________________________
Viktiga designregler under code-alongen
-	Application får aldrig referera API
-	Domain får aldrig referera Application
-	API får referera både Application och Domain
-	All affärslogik ska kunna testas utan HTTP
________________________________________
Efter code-alongen ska ni kunna
-	Förklara varför Console inte längre är centrum
-	Peka ut var ett nytt use case ska implementeras
-	Bygga en ny klient utan att röra Application
-	Se hur detta naturligt kan skalas med databas, auth och tester
Detta är övergången från ”övningsapp” till riktig backend-arkitektur.
